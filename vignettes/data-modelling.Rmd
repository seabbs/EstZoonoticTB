---
title: "Data modelling"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Data mapping}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 12, 
  fig.height = 8,
  dpi = 330
)
```

## Overview


*Work in progress*

## Method

### Data 


```{r setup, include = FALSE}
library(EstZoonoticTB)
library(ggplot2)
library(dplyr)
library(tidyr)
library(mgcv)
library(gratia)
library(truncnorm)
library(brms)
library(future)
```

* Get all data

```{r}
all_data <- link_data(verbose = FALSE)

all_data
```

* Filter down to just countries with data on zoonotic TB presence from 2000 onwards.

```{r}
df_with_ztb <- all_data %>% 
  tidyr::drop_na(tb_z_prop, tb_z_prop_se) %>% 
  dplyr::filter(year >= 2000)

df_with_ztb
```

* Drop countries with a TB incidence rate of less than 1 in 100,000 or with incidence of less than 100.

```{r}
df_with_ztb_filt_tb <- df_with_ztb %>% 
  dplyr::filter(tb_cases >= 100, tb_inc >= 1)

df_with_ztb_filt_tb 
```

* Drop data on presence/absence of zoonotic TB in animals. Drop variables not used in further analysis. 

```{r}
analysis_df <- df_with_ztb_filt_tb %>% 
  dplyr::select(-z_tb_dom_animal, -z_tb_wild_animal, 
                -country_code, - tb_cases, -tb_inc, 
                -tb_inc_lo, -tb_inc_hi, -z_tb_id, -z_tb_geo_coverage,
                -z_tb_study_pop, -tb_z_prop_lo, -tb_z_prop_hi, -population,
                -cattle) %>% 
  dplyr::mutate(id = 1:n())
                



analysis_df 
```

* Check data structure

```{r}
analysis_df %>% 
  summary
```


### Bootstrapping


* Simulate 1000 data points per row using all variable uncertainty. For variables that have no measure of uncertainty a standard error of 2.5% has been assumed.


```{r}
samples <- 5

bootstrapped_df <- analysis_df %>% 
  ## Add noise for variables that we have information about
  mutate(prop_hiv = purrr::map2(prop_hiv, prop_hiv_hi, ~ rtruncnorm(samples, a = 0, b = 1, mean = .x, sd = (.y - .x) / 1.96)),
         tb_z_prop = purrr::map2(tb_z_prop, tb_z_prop_se, ~ rtruncnorm(samples, a = 0, b = 1, mean = .x, sd = .y))) %>% 
  ## Add a 2.5% SE normal noise for numeric variables with no noise.
  mutate_at(.vars = vars(cattle_per_head), 
            ~ purrr::map(., ~ rtruncnorm(samples, a = 0, mean = ., sd = . * 0.025))) %>% 
  mutate_at(.vars = vars(prop_tb_ep, prop_rural), 
            ~ purrr::map(., ~ rtruncnorm(samples, a = 0, b = 1, mean = ., sd = . * 0.025))) %>% 
  mutate(sample = list(tibble::tibble(sample = factor(1:samples)))) %>% 
  dplyr::select(-prop_hiv_lo, -prop_hiv_hi, -tb_z_prop_se) %>% 
  tidyr::unnest(cols = c(prop_tb_ep, prop_hiv, tb_z_prop, prop_rural, cattle_per_head, sample))

bootstrapped_df
```

* Split data into training and test

```{r}
training <- bootstrapped_df  %>% 
  dplyr::filter(year < 2007)

summary(training)
```

```{r}
test <- bootstrapped_df %>% 
  dplyr::filter(year >= 2007)

summary(test)
```

### Modelling


* Evaluation of `brms` measurement model approach.

```{r}
analysis_df <- analysis_df %>% 
  mutate(weights.norm = 1/(tb_z_prop_se^2/mean(tb_z_prop_se^2))) %>% 
  mutate(tb_z_prop = ifelse(tb_z_prop == 0, 1e-10, tb_z_prop),
         prop_hiv_se = (prop_hiv_hi - prop_hiv) / 1.96)

## Split sampled data into seperate data.frames
split_df <- bootstrapped_df %>% 
    mutate_if(is.numeric, scale) %>% 
    group_split(sample) %>% 
    purrr::map(as.data.frame)
 

## Set up parallel processing
plan(multiprocess)

brms_model <- brm(
  bf(tb_z_prop ~ s(year, k = 5) + s(me(prop_hiv, prop_hiv_se)),
  phi ~ -1 + s(weights.norm)),
  data = analysis_df,
  family = Beta(link = "logit", link_phi = "log"),
  control = list(adapt_delta = 0.99, max_treedepth = 20),
  prior = c(prior(horseshoe(1), class = "b"))
)

## Fit a model for each sample and aggregate using Rubins rules (process originally designed for imputed data).
brms_model <- brm_multiple(
  bf(tb_z_prop  ~ 
                  s(year, k = 5) +
                  s(prop_tb_ep) + 
                  s(prop_hiv) +
                  s(prop_rural) + 
                  s(cattle_per_head)),
  data = split_df,
  family = Beta(link = "logit", link_phi = "log"),
  control = list(adapt_delta = 0.99, max_treedepth = 20),
  sample_prior = "yes",
  iter = 2000,
  prior = c(prior(horseshoe(1), class = "b")),
  chains = 2)
```

* Summarise `brms` model

```{r}
summary(brms_model)
```

* `brms` plot model

```{r} 
plot(brms_model, ask = FALSE)
```

* `brms` maginal_effects

```{r}
marginal_effects(brms_model, ask = FALSE)
```
* `brms` model convergence.

```{r}
brms_model$rhats %>% 
  summarise_all(max) %>% 
  t()
```

* Initial model using all covariates, selected using penalised regression.

```{r, eval = FALSE}
# upper limit on k chosen for each covariate using gam.check
basic_model <- bam(tb_z_prop ~
                  ## Global smooths
                  s(year, k = 5) +
                  s(prop_tb_ep, k = 10) + 
                  s(prop_hiv, k = 10) +
                  s(prop_rural, k = 10) + 
                  s(cattle_per_head, k = 10) +
                  ## Sample level smooths
                  s(year, sample, k = 5, bs = "fs") +
                  s(prop_tb_ep, sample, k = 10, bs = "fs") + 
                  s(prop_hiv, sample, k = 10, bs = "fs") +
                  s(prop_rural, sample, k = 10, bs = "fs") + 
                  s(cattle_per_head, sample, k = 10, bs = "fs"),
                  data = training, 
                  family = "betar", 
                  method = "fREML", 
                  select = TRUE)


summary(basic_model)

draw(basic_model)
```

```{r, eval = FALSE}
gam.check(basic_model)
```

* Complex model using all pairwise interactions. Again penalised to remove confounders.

```{r, eval = FALSE}
complex_model <- bam(tb_z_prop ~
                  ## Global smooths
                  s(year, k = 5) +
                  s(prop_tb_ep, k = 10) + 
                  s(prop_hiv, k = 10) +
                  s(prop_rural, k = 10) + 
                  s(cattle_per_head, k = 10) +
                  ## Sample level smooths
                  s(year, sample, k = 5, bs = "fs") +
                  s(prop_tb_ep, sample, k = 10, bs = "fs") + 
                  s(prop_hiv, sample, k = 10, bs = "fs") +
                  s(prop_rural, sample, k = 10, bs = "fs") + 
                  s(cattle_per_head, sample, k = 10, bs = "fs") +
                  ## Interactions with year
                  ti(year, prop_tb_ep) +
                  ti(year, prop_hiv) + 
                  ti(year, prop_rural) +
                  ti(year, cattle_per_head) +
                  ## Interactions with proportion ep
                  ti(prop_tb_ep, prop_hiv) +
                  ti(prop_tb_ep, prop_rural) + 
                  ti(prop_tb_ep, cattle_per_head) +
                  ## Interactions with proportion HIV
                  ti(prop_hiv, prop_rural) +
                  ti(prop_hiv, cattle_per_head) + 
                  ## Interactions with proportion rural
                  ti(prop_rural, cattle_per_head),
                  data = training, 
                  family = "betar", 
                  method = "fREML", 
                  select = TRUE,
                  samfrac = 0.1)


summary(complex_model)

draw(complex_model)
```


```{r, eval = FALSE}
gam.check(complex_model)
```